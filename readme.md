### Консольная утилита, распаралеливающая долгий запрос на чтение из БД с последующей выгрузкой результатов в файл.

* Класс **AppSettings** - для чтения настроек из xml файла:
  * текст распараллеленного sql;
  * количество потоков выполнения;
  * тип формируемого отчета, (пока ограничусь csv);
  * писать ли шапку отчета;
  * кодовая страница отчета
  * имя файла отчета
  * url соединения с БД

  Источник загрузки настроек определяется типом SettingsType.

  Реализована загрузка параметров из XML файла

  Логин и пароль соединения c БД из соображений безопасности, читаю из System.getProperties, (командная строка).

* Класс **DBCPDataSource** открывает пул соединений с PostgreSQL, реализован через org.apache.commons.dbcp.BasicDataSource.

* Класс **DataProducer** запускает заданное количество задач, (потоков) с распараллелеными запросами к БД.
  
  Количество запущенных запросов определяется параметром из настроек threadsCount

  Результаты работы каждого запроса в потоке построчно выгружается в очередь сообщений BlockingQueue<String>

  После окончания работы всех запросов в очередь посылается сообщение "отравленная пилюля" POISON_PILL - сигнал читателю очереди окончить работу

* Класс **Consumer**, в отдельном потоке, в цикле читает строки из очереди сообщений BlockingQueue<String> и  записывает в файл отчета.

  Пока в очереди не появится сообщение POISON_PILL, в потоке опрашивает очередь на новые записи.

  Открывает файл отчета на запись и построчно заполняет сообщениями из очереди
  
  Цикл чтения прерывается сообщением в очереди POISON_PILL

* БД: PostgreSQL. Запрос возвращает 500_000 строк. Каждая строка содержит primary key id типа id serial4 NOT NULL.

  Распаралеливание в SQL подзапросах реализовано при помощи условия разбиения на подзапросы : where mod(id, threadCounter) = 0..threadCounter - 1
  
* Как показали полевые испытания, 1 поток работает быстрее, чем 4 :) Причиной может быть не удачный выбор SQL. 
  
  Как не старался, нагрузить программу как следует, не удалось.